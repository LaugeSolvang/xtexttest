/*
 * generated by Xtext 2.33.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import org.xtext.example.mydsl.myDsl.*
import java.util.List
import org.eclipse.emf.ecore.EPackage
import org.eclipse.emf.ecore.EClass
import java.util.ArrayList
import org.eclipse.emf.ecore.EAttribute
import org.eclipse.emf.ecore.EReference


/**
 * Generates code from your model files on save.
 */
class MyDslGenerator extends AbstractGenerator {

    static class FieldInfo {
        String type
        String name
        boolean isCollection = false
        String defaultInitializer = null
        
        new(String type, String name) {
            this.type = type
            this.name = name
        }
        
        new(String type, String name, boolean isCollection, String defaultInitializer) {
            this.type = type
            this.name = name
            this.isCollection = isCollection
            this.defaultInitializer = defaultInitializer
        }
    }

    override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
    val model = resource.allContents.filter(Model).head
    
    // Access the generated metamodel package using the URI from your grammar
    val packageNsURI = "http://www.xtext.org/example/mydsl/MyDsl"
    val myDslPackage = EPackage.Registry.INSTANCE.getEPackage(packageNsURI)
        
    // Get the entity classes from the package
    val entities = #["Story", "Player", "Location", "NPC", "Item", "Action", "Quest", "Attribute"]
    
    for (entityName : entities) {
        val eClass = myDslPackage.getEClassifier(entityName) as EClass
        if (eClass !== null) {
            var fields = extractFields(eClass)
            
            if (entityName == "Player") {
                fields.add(new FieldInfo("Location", "currentLocation", false, null))
            }
            if (entityName == "Attribute") {
                    val expFieldInfo = fields.findFirst[name == "exp" ] // Find by metamodel name 'exp'

                    if (expFieldInfo !== null) {
                        fields.remove(expFieldInfo)
                    } else {
                         System.err.println("Warning: Could not find 'exp' field to replace in Attribute fields list.");
                    }
                    fields.add(new FieldInfo("Integer", "value", false, null))
                }
            
            fsa.generateFile('''game/«entityName».java''', generateClass(entityName, fields))
        } else {
            System.err.println("Warning: Could not find EClass for " + entityName)
        }
    }
    
    // Generate Game class
    fsa.generateFile("game/GameInitializer.java", generateGameInitializerClass(model))
	}
		
	def List<FieldInfo> extractFields(EClass eClass) {
	    val fields = new ArrayList<FieldInfo>()
	    
	    // Process all structural features (attributes and references)
	    eClass.EAllStructuralFeatures.forEach[feature |
	        val name = feature.name
	        var type = ""
	        var isCollection = feature.many
	        var defaultInitializer = if (isCollection) "ArrayList" else null
	        
	        if (feature instanceof EAttribute) {
	            // Handle attributes (primitive types)
	            switch (feature.EAttributeType.name) {
	                case "EString": type = "String"
	                case "EInt": type = "Integer"
	                case "EBoolean": type = "Boolean"
	                default: type = "String" // fallback
	            }
	        } else if (feature instanceof EReference) {
	            // Handle references (object types)
	            type = feature.EReferenceType.name
	            if (isCollection) {
	                type = "List<" + type + ">"
	            }
	        }
	        
	        fields.add(new FieldInfo(type, name, isCollection, defaultInitializer))
	    ]
	    
	    return fields
	}
    def generateClass(String className, List<FieldInfo> fields) {
	    '''
	    package game;
	    
	    import java.util.*;
	    
	    public class «className» {
	        «FOR field : fields»
	        private «field.type» «field.name»;
	        «ENDFOR»
	        
	        public «className»(«fields.map[type + " " + name].join(", ")») {
	            «FOR field : fields»
	            this.«field.name» = «field.name»«IF field.isCollection» != null ? «field.name» : new «field.defaultInitializer»<>()«ENDIF»;
	            «ENDFOR»
	        }
	        
	        «FOR field : fields»
	        public «field.type» get«field.name.toFirstUpper»() { return «field.name»; }
	        public void set«field.name.toFirstUpper»(«field.type» «field.name») { this.«field.name» = «field.name»; }
	        «ENDFOR»
	    }
	    '''
	}
	
	def int evaluate(Exp expression) {
        switch expression {
            Number: expression.value
            Ref:    evaluate(expression.value.exp) // FIXED: Use .value here (based on grammar {Ref} value = ...)
            Plus:   evaluate(expression.left) + evaluate(expression.right)
            Minus:  evaluate(expression.left) - evaluate(expression.right)
            Mul:    evaluate(expression.left) * evaluate(expression.right)
            Div:    {
                        val rightVal = evaluate(expression.right)
                        if (rightVal == 0) {
                            println("Warning: Division by zero encountered during generation (returning 0).")
                            0
                        } else {
                             evaluate(expression.left) / rightVal
                        }
                    }
            ParenthesizedExpression: evaluate(expression.inner)
            default: {
                     println("Error: Unknown expression type encountered during evaluation: " + expression.eClass.name)
                     0
                }
        }
    }
    
    def generateGameInitializerClass(Model model) {
        '''
        package game;
        
        import java.util.*;
        import java.util.stream.Collectors;
        
        public class GameInitializer {
        	private static Map<String, Location> locations = new HashMap<>();
        	    private static Map<String, Item> items = new HashMap<>();
        	    private static Map<String, NPC> npcs = new HashMap<>();
        	    private static Map<String, Action> actions = new HashMap<>();
        	    private static Player player;
        	    private static Story story;
        	public static void initializeWorld() {
        	                // Create Actions
        	                «FOR actionsGroup : model.elem.filter(Actions)»
        	                    «FOR action : actionsGroup.action»
        	                    actions.put("«action.name»", new Action("«action.name»", "«action.command»", "«action.effect»"));
        	                    «ENDFOR»
        	                «ENDFOR»
        	                
        	                // Create Items
        	                «FOR itemsGroup : model.elem.filter(Items)»
        	                    «FOR item : itemsGroup.item»
        	                    items.put("«item.name»", new Item("«item.name»", "«item.desc»", 
        	                    Arrays.asList(«IF item.actions.empty»«ELSE»«FOR a : item.actions SEPARATOR ', '»actions.get("«a.name»")«ENDFOR»«ENDIF»)));
        	                    «ENDFOR»
        	                «ENDFOR»
        	                
        	                // Create NPCs
        	                «FOR npcsGroup : model.elem.filter(NPCs)»
        	                    «FOR npc : npcsGroup.npc»
        	                    npcs.put("«npc.name»", new NPC("«npc.name»", 
        	                    Arrays.asList(«IF npc.items.empty»«ELSE»«FOR i : npc.items SEPARATOR ', '»items.get("«i.name»")«ENDFOR»«ENDIF»), 
        	                    Arrays.asList(«IF npc.actions.empty»«ELSE»«FOR a : npc.actions SEPARATOR ', '»actions.get("«a.name»")«ENDFOR»«ENDIF»)));
        	                    «ENDFOR»
        	                «ENDFOR»
        	                
        	                // Create Locations
        	                «FOR locationsGroup : model.elem.filter(Locations)»
        	                    «FOR location : locationsGroup.locations»
        	                    locations.put("«location.name»", new Location("«location.name»", 
        	                    new ArrayList<>(Arrays.asList(«IF location.NPCs.empty»«ELSE»«FOR n : location.NPCs SEPARATOR ', '»npcs.get("«n.name»")«ENDFOR»«ENDIF»)), 
        	                    new ArrayList<>(Arrays.asList(«IF location.items.empty»«ELSE»«FOR i : location.items SEPARATOR ', '»items.get("«i.name»")«ENDFOR»«ENDIF»)), 
        	                    new ArrayList<>()));
        	                    «ENDFOR»
        	                «ENDFOR»
        	                
        	                // Set up location connections
        	                «FOR locationsGroup : model.elem.filter(Locations)»
        	                    «FOR location : locationsGroup.locations»
        	                        «FOR conn : location.connections»
        	                        locations.get("«location.name»").getConnections().add(locations.get("«conn.name»"));
        	                        «ENDFOR»
        	                    «ENDFOR»
        	                «ENDFOR»
        	                
        	                «val player = model.elem.filter(Player).head»
        	                List<Attribute> playerAttributes = new ArrayList<>();
        	                
        	                «IF player !== null»
        	                    «FOR attr : player.attributes» 
        	                        «val evaluatedValue = evaluate(attr.exp)» 
        	                        playerAttributes.add(new Attribute("«attr.name»", «evaluatedValue»)); 
        	                    «ENDFOR»
        	                «ENDIF»
        	
        	                
        	      
        	                player = new Player("«player?.name ?: "DefaultPlayer"»",
        	                new ArrayList<>(Arrays.asList(«IF player?.actions.empty»«ELSE»«FOR a : player?.actions ?: emptyList SEPARATOR ', '»actions.get("«a.name»")«ENDFOR»«ENDIF»)),
        	                new ArrayList<>(Arrays.asList(«IF player?.inventory.empty»«ELSE»«FOR i : player?.inventory ?: emptyList SEPARATOR ', '»items.get("«i.name»")«ENDFOR»«ENDIF»)),
        	                playerAttributes,
        	                locations.get("«model.elem.filter(Story).head?.startLocation?.name ?: ""»"));                    
        	                // Create Story
        	                «val story = model.elem.filter(Story).head»
        	                Story story = new Story("«story?.name ?: ""»", 
        	                    "«story?.desc ?: ""»", 
        	                locations.get("«story?.startLocation?.name ?: ""»"));
        	            }
        	             public static Player getPlayer() {
        	                    return player;
        	                }
        	            
        	                public static Story getStory() {
        	                    return story;
        	                }
        }
        '''
    }
}